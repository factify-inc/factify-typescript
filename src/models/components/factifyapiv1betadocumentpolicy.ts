/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  FactifyApiV1betaPolicy,
  FactifyApiV1betaPolicy$inboundSchema,
} from "./factifyapiv1betapolicy.js";
import {
  FactifyApiV1betaUser,
  FactifyApiV1betaUser$inboundSchema,
} from "./factifyapiv1betauser.js";

/**
 * DocumentPolicy represents a policy attached to a document.
 */
export type FactifyApiV1betaDocumentPolicy = {
  /**
   * Document ID this policy is attached to.
   *
   * @remarks
   *  Pattern: doc_[0-9a-hjkmnp-tv-z]{26}
   */
  documentId: string;
  /**
   * A Timestamp represents a point in time independent of any time zone or local
   *
   * @remarks
   *  calendar, encoded as a count of seconds and fractions of seconds at
   *  nanosecond resolution. The count is relative to an epoch at UTC midnight on
   *  January 1, 1970, in the proleptic Gregorian calendar which extends the
   *  Gregorian calendar backwards to year one.
   *
   *  All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap
   *  second table is needed for interpretation, using a [24-hour linear
   *  smear](https://developers.google.com/time/smear).
   *
   *  The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
   *  restricting to that range, we ensure that we can convert to and from [RFC
   *  3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
   *
   *  # Examples
   *
   *  Example 1: Compute Timestamp from POSIX `time()`.
   *
   *      Timestamp timestamp;
   *      timestamp.set_seconds(time(NULL));
   *      timestamp.set_nanos(0);
   *
   *  Example 2: Compute Timestamp from POSIX `gettimeofday()`.
   *
   *      struct timeval tv;
   *      gettimeofday(&tv, NULL);
   *
   *      Timestamp timestamp;
   *      timestamp.set_seconds(tv.tv_sec);
   *      timestamp.set_nanos(tv.tv_usec * 1000);
   *
   *  Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.
   *
   *      FILETIME ft;
   *      GetSystemTimeAsFileTime(&ft);
   *      UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;
   *
   *      // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
   *      // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
   *      Timestamp timestamp;
   *      timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
   *      timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));
   *
   *  Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.
   *
   *      long millis = System.currentTimeMillis();
   *
   *      Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
   *          .setNanos((int) ((millis % 1000) * 1000000)).build();
   *
   *  Example 5: Compute Timestamp from Java `Instant.now()`.
   *
   *      Instant now = Instant.now();
   *
   *      Timestamp timestamp =
   *          Timestamp.newBuilder().setSeconds(now.getEpochSecond())
   *              .setNanos(now.getNano()).build();
   *
   *  Example 6: Compute Timestamp from current time in Python.
   *
   *      timestamp = Timestamp()
   *      timestamp.GetCurrentTime()
   *
   *  # JSON Mapping
   *
   *  In JSON format, the Timestamp type is encoded as a string in the
   *  [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
   *  format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
   *  where {year} is always expressed using four digits while {month}, {day},
   *  {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
   *  seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
   *  are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
   *  is required. A proto3 JSON serializer should always use UTC (as indicated by
   *  "Z") when printing the Timestamp type and a proto3 JSON parser should be
   *  able to accept both UTC and other timezones (as indicated by an offset).
   *
   *  For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
   *  01:30 UTC on January 15, 2017.
   *
   *  In JavaScript, one can convert a Date object to this format using the
   *  standard
   *  [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
   *  method. In Python, a standard `datetime.datetime` object can be converted
   *  to this format using
   *  [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
   *  the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
   *  the Joda Time's [`ISODateTimeFormat.dateTime()`](
   *  http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()
   *  ) to obtain a formatter capable of generating timestamps in this format.
   */
  attachedAt: Date;
  /**
   * User represents a user or service account.
   */
  attachedBy: FactifyApiV1betaUser;
  /**
   * Policy represents a governance policy.
   */
  policy: FactifyApiV1betaPolicy;
};

/** @internal */
export const FactifyApiV1betaDocumentPolicy$inboundSchema: z.ZodMiniType<
  FactifyApiV1betaDocumentPolicy,
  unknown
> = z.pipe(
  z.object({
    document_id: types.string(),
    attached_at: types.date(),
    attached_by: FactifyApiV1betaUser$inboundSchema,
    policy: FactifyApiV1betaPolicy$inboundSchema,
  }),
  z.transform((v) => {
    return remap$(v, {
      "document_id": "documentId",
      "attached_at": "attachedAt",
      "attached_by": "attachedBy",
    });
  }),
);

export function factifyApiV1betaDocumentPolicyFromJSON(
  jsonString: string,
): SafeParseResult<FactifyApiV1betaDocumentPolicy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FactifyApiV1betaDocumentPolicy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FactifyApiV1betaDocumentPolicy' from JSON`,
  );
}
