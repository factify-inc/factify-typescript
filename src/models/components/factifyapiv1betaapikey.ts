/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * ApiKey represents an authentication credential for programmatic API access.
 */
export type FactifyApiV1betaApiKey = {
  /**
   * Unique ID for the API key.
   *
   * @remarks
   *  Pattern: key_[0-9a-hjkmnp-tv-z]{26}
   */
  id: string;
  /**
   * Human-readable name for the key (e.g., "Production", "Staging").
   */
  name: string;
  /**
   * ID of the organization this key belongs to.
   *
   * @remarks
   *  Pattern: org_[0-9a-hjkmnp-tv-z]{26}
   */
  organizationId: string;
  /**
   * A Timestamp represents a point in time independent of any time zone or local
   *
   * @remarks
   *  calendar, encoded as a count of seconds and fractions of seconds at
   *  nanosecond resolution. The count is relative to an epoch at UTC midnight on
   *  January 1, 1970, in the proleptic Gregorian calendar which extends the
   *  Gregorian calendar backwards to year one.
   *
   *  All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap
   *  second table is needed for interpretation, using a [24-hour linear
   *  smear](https://developers.google.com/time/smear).
   *
   *  The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
   *  restricting to that range, we ensure that we can convert to and from [RFC
   *  3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
   *
   *  # Examples
   *
   *  Example 1: Compute Timestamp from POSIX `time()`.
   *
   *      Timestamp timestamp;
   *      timestamp.set_seconds(time(NULL));
   *      timestamp.set_nanos(0);
   *
   *  Example 2: Compute Timestamp from POSIX `gettimeofday()`.
   *
   *      struct timeval tv;
   *      gettimeofday(&tv, NULL);
   *
   *      Timestamp timestamp;
   *      timestamp.set_seconds(tv.tv_sec);
   *      timestamp.set_nanos(tv.tv_usec * 1000);
   *
   *  Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.
   *
   *      FILETIME ft;
   *      GetSystemTimeAsFileTime(&ft);
   *      UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;
   *
   *      // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
   *      // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
   *      Timestamp timestamp;
   *      timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
   *      timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));
   *
   *  Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.
   *
   *      long millis = System.currentTimeMillis();
   *
   *      Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
   *          .setNanos((int) ((millis % 1000) * 1000000)).build();
   *
   *  Example 5: Compute Timestamp from Java `Instant.now()`.
   *
   *      Instant now = Instant.now();
   *
   *      Timestamp timestamp =
   *          Timestamp.newBuilder().setSeconds(now.getEpochSecond())
   *              .setNanos(now.getNano()).build();
   *
   *  Example 6: Compute Timestamp from current time in Python.
   *
   *      timestamp = Timestamp()
   *      timestamp.GetCurrentTime()
   *
   *  # JSON Mapping
   *
   *  In JSON format, the Timestamp type is encoded as a string in the
   *  [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
   *  format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
   *  where {year} is always expressed using four digits while {month}, {day},
   *  {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
   *  seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
   *  are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
   *  is required. A proto3 JSON serializer should always use UTC (as indicated by
   *  "Z") when printing the Timestamp type and a proto3 JSON parser should be
   *  able to accept both UTC and other timezones (as indicated by an offset).
   *
   *  For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
   *  01:30 UTC on January 15, 2017.
   *
   *  In JavaScript, one can convert a Date object to this format using the
   *  standard
   *  [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
   *  method. In Python, a standard `datetime.datetime` object can be converted
   *  to this format using
   *  [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
   *  the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
   *  the Joda Time's [`ISODateTimeFormat.dateTime()`](
   *  http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()
   *  ) to obtain a formatter capable of generating timestamps in this format.
   */
  createdAt: Date;
  /**
   * A Timestamp represents a point in time independent of any time zone or local
   *
   * @remarks
   *  calendar, encoded as a count of seconds and fractions of seconds at
   *  nanosecond resolution. The count is relative to an epoch at UTC midnight on
   *  January 1, 1970, in the proleptic Gregorian calendar which extends the
   *  Gregorian calendar backwards to year one.
   *
   *  All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap
   *  second table is needed for interpretation, using a [24-hour linear
   *  smear](https://developers.google.com/time/smear).
   *
   *  The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
   *  restricting to that range, we ensure that we can convert to and from [RFC
   *  3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
   *
   *  # Examples
   *
   *  Example 1: Compute Timestamp from POSIX `time()`.
   *
   *      Timestamp timestamp;
   *      timestamp.set_seconds(time(NULL));
   *      timestamp.set_nanos(0);
   *
   *  Example 2: Compute Timestamp from POSIX `gettimeofday()`.
   *
   *      struct timeval tv;
   *      gettimeofday(&tv, NULL);
   *
   *      Timestamp timestamp;
   *      timestamp.set_seconds(tv.tv_sec);
   *      timestamp.set_nanos(tv.tv_usec * 1000);
   *
   *  Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.
   *
   *      FILETIME ft;
   *      GetSystemTimeAsFileTime(&ft);
   *      UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;
   *
   *      // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
   *      // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
   *      Timestamp timestamp;
   *      timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
   *      timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));
   *
   *  Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.
   *
   *      long millis = System.currentTimeMillis();
   *
   *      Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
   *          .setNanos((int) ((millis % 1000) * 1000000)).build();
   *
   *  Example 5: Compute Timestamp from Java `Instant.now()`.
   *
   *      Instant now = Instant.now();
   *
   *      Timestamp timestamp =
   *          Timestamp.newBuilder().setSeconds(now.getEpochSecond())
   *              .setNanos(now.getNano()).build();
   *
   *  Example 6: Compute Timestamp from current time in Python.
   *
   *      timestamp = Timestamp()
   *      timestamp.GetCurrentTime()
   *
   *  # JSON Mapping
   *
   *  In JSON format, the Timestamp type is encoded as a string in the
   *  [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
   *  format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
   *  where {year} is always expressed using four digits while {month}, {day},
   *  {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
   *  seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
   *  are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
   *  is required. A proto3 JSON serializer should always use UTC (as indicated by
   *  "Z") when printing the Timestamp type and a proto3 JSON parser should be
   *  able to accept both UTC and other timezones (as indicated by an offset).
   *
   *  For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
   *  01:30 UTC on January 15, 2017.
   *
   *  In JavaScript, one can convert a Date object to this format using the
   *  standard
   *  [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
   *  method. In Python, a standard `datetime.datetime` object can be converted
   *  to this format using
   *  [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
   *  the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
   *  the Joda Time's [`ISODateTimeFormat.dateTime()`](
   *  http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()
   *  ) to obtain a formatter capable of generating timestamps in this format.
   */
  expiresAt?: Date | undefined;
  /**
   * Whether the key is currently active (not revoked and not expired).
   *
   * @remarks
   *  Computed: is_active = (revoked_at == null) && (expires_at == null || expires_at > now())
   */
  isActive: boolean;
  /**
   * Truncated key prefix for identification in UI (e.g., "ffy_prod_01jd4h5...").
   *
   * @remarks
   *  Shows the first 16 characters for better uniqueness while maintaining security.
   */
  keyPrefix: string;
  /**
   * A Timestamp represents a point in time independent of any time zone or local
   *
   * @remarks
   *  calendar, encoded as a count of seconds and fractions of seconds at
   *  nanosecond resolution. The count is relative to an epoch at UTC midnight on
   *  January 1, 1970, in the proleptic Gregorian calendar which extends the
   *  Gregorian calendar backwards to year one.
   *
   *  All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap
   *  second table is needed for interpretation, using a [24-hour linear
   *  smear](https://developers.google.com/time/smear).
   *
   *  The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
   *  restricting to that range, we ensure that we can convert to and from [RFC
   *  3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
   *
   *  # Examples
   *
   *  Example 1: Compute Timestamp from POSIX `time()`.
   *
   *      Timestamp timestamp;
   *      timestamp.set_seconds(time(NULL));
   *      timestamp.set_nanos(0);
   *
   *  Example 2: Compute Timestamp from POSIX `gettimeofday()`.
   *
   *      struct timeval tv;
   *      gettimeofday(&tv, NULL);
   *
   *      Timestamp timestamp;
   *      timestamp.set_seconds(tv.tv_sec);
   *      timestamp.set_nanos(tv.tv_usec * 1000);
   *
   *  Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.
   *
   *      FILETIME ft;
   *      GetSystemTimeAsFileTime(&ft);
   *      UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;
   *
   *      // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
   *      // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
   *      Timestamp timestamp;
   *      timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
   *      timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));
   *
   *  Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.
   *
   *      long millis = System.currentTimeMillis();
   *
   *      Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
   *          .setNanos((int) ((millis % 1000) * 1000000)).build();
   *
   *  Example 5: Compute Timestamp from Java `Instant.now()`.
   *
   *      Instant now = Instant.now();
   *
   *      Timestamp timestamp =
   *          Timestamp.newBuilder().setSeconds(now.getEpochSecond())
   *              .setNanos(now.getNano()).build();
   *
   *  Example 6: Compute Timestamp from current time in Python.
   *
   *      timestamp = Timestamp()
   *      timestamp.GetCurrentTime()
   *
   *  # JSON Mapping
   *
   *  In JSON format, the Timestamp type is encoded as a string in the
   *  [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
   *  format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
   *  where {year} is always expressed using four digits while {month}, {day},
   *  {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
   *  seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
   *  are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
   *  is required. A proto3 JSON serializer should always use UTC (as indicated by
   *  "Z") when printing the Timestamp type and a proto3 JSON parser should be
   *  able to accept both UTC and other timezones (as indicated by an offset).
   *
   *  For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
   *  01:30 UTC on January 15, 2017.
   *
   *  In JavaScript, one can convert a Date object to this format using the
   *  standard
   *  [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
   *  method. In Python, a standard `datetime.datetime` object can be converted
   *  to this format using
   *  [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
   *  the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
   *  the Joda Time's [`ISODateTimeFormat.dateTime()`](
   *  http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()
   *  ) to obtain a formatter capable of generating timestamps in this format.
   */
  revokedAt?: Date | undefined;
};

/** @internal */
export const FactifyApiV1betaApiKey$inboundSchema: z.ZodMiniType<
  FactifyApiV1betaApiKey,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    name: types.string(),
    organization_id: types.string(),
    created_at: types.date(),
    expires_at: types.optional(types.date()),
    is_active: types.boolean(),
    key_prefix: types.string(),
    revoked_at: types.optional(types.date()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "organization_id": "organizationId",
      "created_at": "createdAt",
      "expires_at": "expiresAt",
      "is_active": "isActive",
      "key_prefix": "keyPrefix",
      "revoked_at": "revokedAt",
    });
  }),
);

export function factifyApiV1betaApiKeyFromJSON(
  jsonString: string,
): SafeParseResult<FactifyApiV1betaApiKey, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FactifyApiV1betaApiKey$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FactifyApiV1betaApiKey' from JSON`,
  );
}
